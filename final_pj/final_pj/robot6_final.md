
# TurtleBot4 로비 안내 로봇(robot6) 개발 작업 요약

**문서 목적**: 본 문서는 TurtleBot4(robot6)의 로비 안내 기능 개발 과정에서 발생한 문제들을 해결하고, 최종적으로 구현된 소프트웨어 아키텍처를 공유하기 위해 작성되었습니다.

---

## 1. 메인 제어 노드(`loby_bot6.py`) 생성 및 아키텍처 재설계

### 1.1. 초기 문제점

기존 시스템은 `lobby_guide_navigator_node.py`가 주행 로직을 담당하고, 사람 인식이 필요할 때 `dd_final.py`가 실행하는 액션 서버(`detect_and_measure`)를 호출하는 구조였습니다.

- **문제 현상**: `lobby_guide_navigator_node.py`가 사람 인식을 위해 액션 클라이언트로서 `dd_final.py`에 목표(goal)를 전송하면, 액션 서버의 응답을 기다리는 과정에서 **코드가 더 이상 진행되지 않고 멈추는 현상**이 발생했습니다.
- **예상 원인**: 두 노드 간의 액션 통신 과정에서 발생하는 동기화 또는 블로킹(blocking) 문제로 추정되었습니다.

### 1.2. 해결 방안

복잡한 노드 간 통신 문제를 해결하고 시스템 안정성을 높이기 위해, 여러 노드에 분산되어 있던 핵심 기능들을 하나의 메인 제어 노드로 통합하는 새로운 아키텍처를 설계했습니다.

- **새로운 메인 노드**: `loby_bot6.py`를 생성하여 전체 시나리오를 총괄하도록 했습니다.
- **기능 통합**:
    - 기존 `lobby_guide_navigator_node.py`의 **네비게이션 및 주행 로직**을 `loby_bot6.py`로 이전했습니다.
    - 기존 `dd_final.py`의 **YOLOv8 기반 사람 인식 및 깊이 측정 로직**을 `loby_bot6.py` 내의 백그라운드 스레드로 통합했습니다.
- **통신 방식 변경**:
    - 외부 노드와의 복잡한 액션 통신 대신, `loby_bot6.py` 내부에서 직접 `wait_for_human_detection` 함수를 호출하여 사람을 기다리도록 변경했습니다. 이로써 불안정한 통신으로 인한 블로킹 문제를 원천적으로 제거했습니다.
    - 외부 연동 가능성을 위해, 요청에 따라 `detect_and_measure` 액션 서버 기능은 `loby_bot6.py` 내에 그대로 유지했습니다.

### 1.3. 수행 내역 및 결과

위 해결 방안에 따라 `loby_bot6.py` 파일을 생성하고 아래의 기능들을 구현했습니다.

- **통합 제어**: 배터리 상태 확인, 전시관 선택, 도킹 해제, 회전, 주행, 사람 인식 대기, 복귀 등 모든 안내 시나리오를 순차적으로 제어합니다.
- **내장된 사람 인식**:
    - 멀티스레딩을 활용하여, 메인 제어 로직과 별개로 카메라로부터 영상(RGB, Depth)을 받아 실시간으로 사람을 탐지하는 `detection_loop`를 백그라운드에서 실행합니다.
    - 사람이 1.5m 이내로 감지되면, 성공 여부(True)와 측정된 거리를 반환하는 `wait_for_human_detection` 함수를 통해 안정적으로 사람을 기다립니다.
- **안전한 예외 처리**: 사람 인식이 지정된 시간 내에 실패할 경우, 안내를 중단하고 안전하게 초기 위치(`home_pose`)로 복귀하는 로직을 추가했습니다.

**- 최종 생성 파일:** `/home/ohjunseok/rokey4_C3_ws/src/final_pj/final_pj/loby_bot6.py`

---

## 2. 사용자 입력 노드(`select_monitor_mdfy.py`) 안정성 개선

### 2.1. 초기 문제점

사용자가 터미널에서 안내받을 전시관 번호를 입력하는 `select_monitor_mdfy.py` 노드에서 입력 지연 및 누락 현상이 발생했습니다.

- **문제 현상**: 터미널에 번호를 한 번만 입력해도, 노드가 이를 즉시 인식하지 못하고 **여러 번 입력을 반복해야만 겨우 처리**되는 문제가 있었습니다.
- **원인 분석**: 기존 코드는 타임아웃 기능이 있는 입력을 구현하기 위해 `input()` 함수를 매번 별도의 스레드(thread)에서 실행했습니다. 이 방식은 루프가 반복될 때마다 새로운 스레드를 계속 생성하여, 여러 스레드가 터미널 입력을 두고 경쟁하면서 입력을 가로채거나 누락시키는 원인이 되었습니다.

### 2.2. 해결 방안

불필요한 스레드 생성을 피하고 안정적으로 입력을 처리하기 위해, Python의 내장 모듈인 `select`를 사용하는 방식으로 코드를 전면 수정했습니다.

- **`get_input_with_timeout` 함수 재구현**:
    - `threading`과 `queue` 모듈을 사용하는 대신, `select.select()` 함수를 사용하여 지정된 시간 동안만 표준 입력(stdin) 파일 디스크립터를 감시합니다.
    - 이 방식은 단일 스레드에서 동작하므로 리소스 경쟁 없이 안정적으로 사용자 입력을 처리할 수 있습니다.
- **코드 구조 개선**:
    - 메인 루프의 로직을 더 명확하게 다듬고, 서비스 호출 부분을 별도 함수로 분리하여 가독성과 안정성을 높였습니다.

### 2.3. 수행 내역 및 결과

위 해결 방안을 적용하여 `smm_mdfy.py` 라는 이름의 새 파일을 생성했습니다.

- **즉각적인 입력 처리**: 사용자가 터미널에 값을 입력하면, 지연이나 누락 없이 즉시 인식하여 다음 로직을 수행합니다.
- **안정성 향상**: 불필요한 스레드 생성을 제거하여 프로그램의 전반적인 안정성과 예측 가능성을 높였습니다.

**- 최종 생성 파일:** `/home/ohjunseok/rokey4_C3_ws/src/final_pj/final_pj/smm_mdfy.py`

---

## 결론

위 두 가지 주요 개선 작업을 통해 TurtleBot4 안내 로봇의 소프트웨어 안정성과 신뢰성을 크게 향상했습니다. 핵심 로직을 `loby_bot6.py`로 통합하여 노드 간 통신 문제를 해결했으며, `smm_mdfy.py`의 입력 처리 방식을 개선하여 사용자 인터페이스의 반응성을 높였습니다.
